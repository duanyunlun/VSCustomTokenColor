2026-01-29 16:08:57

# VS Code 语义 Token 配色插件（Token Styler）工作计划

## 0. 本计划的前提与澄清
- 本计划**不包含“从 VS/VS2022 导入颜色”**的功能与实现（该步骤仅为个人偏好配置，不作为扩展核心能力）。
- 目标围绕：**“标准 token types（LSP 标准）+ 特定语言扩展 token types（按语言分组）”**的图形化配置、预览与落地。

## 1. 启动项目的缘由（Why now）
1) VS Code 原生设置 editor.semanticTokenColorCustomizations 为 JSON/JSONC，维护成本高、难以验证、易产生“无意覆盖/污染”。
2) 不同语言扩展（如 C#）会额外贡献 token types；用户很难系统性地发现、解释、配置，并在配置变更后快速验证效果。
3) 缺少“实时预览”的交互：用户只能反复修改 settings、打开文件对比，效率低。
4) 希望形成一套可复用的配置域：
   - 标准层（LSP 标准 token types）作为全局基础
   - 语言层（某语言扩展的 token types）覆盖基础层
   - UI 语言为英文显示 tokenType 原名，中文显示简短语义标签（如 C#.常量标识符）

## 2. 成果定义（What we will deliver）
### 2.1 MVP（第一阶段可交付）
- 一个 VS Code 扩展，提供：
  1) **图形化编辑** oreground + old/italic/underline（不支持 token 级 font family/size，这是 VS Code 限制）。
  2) **配置域分层**：
     - 标准 token types（LSP 23）
     - 语言 token types（以 C# 为首个适配语言）
     - 语言层覆盖标准层（同名 selector 覆盖）
  3) **实时预览**：通过“预览编辑器 + 内置代码片段”展示效果（不是取色器，而是代码片段渲染预览）。
  4) **主题绑定**：支持不同主题使用不同配置（Theme-scoped Profiles）。
  5) **安全写入与回滚**：写入用户级/工作区级 settings，并提供一键恢复（restore）上一次写入前快照。

### 2.2 后续增强（非 MVP）
- 动态模式：模拟“按语言生效”（监听当前活动编辑器 languageId，动态应用对应语言层覆盖）。
- 多语言扩展适配（C/C++、TS/JS、Python…）。
- 导入/导出 Profiles（JSON）。

## 3. 范围与非范围（Scope / Non-goals）
### 3.1 Scope（做）
- 语义 token 的样式：oreground + old/italic/underline。
- Profiles：多份配置，可启用/禁用，可绑定主题。
- 语言 token types 列表来源：从已安装扩展 package.json contributes.semanticTokenTypes 自动发现。
- UI 本地化：根据 scode.env.language 切换显示标签（英文 tokenType / 中文语义标签）。

### 3.2 Non-goals（不做）
- 从 VS/VS2022 导入颜色。
- token 级别字体族/字号（VS Code 不支持）。
- 伪高亮（在 webview 内手写高亮）：预览以 VS Code 实际渲染为准。

## 4. 关键约束与风险
1) VS Code 原生 semantic token 规则**无法真正按语言隔离**（同一主题下 keyword 会影响所有语言的 keyword）。
   - 方案：MVP 先做“静态模式（按主题）”。
   - 扩展：后续提供“动态模式”模拟按语言切换（需明确副作用：会频繁写 settings，可能影响多窗口）。
2) 扩展贡献的 token types ≠ 语言服务一定输出该 token。
   - 方案：UI 提供“预览片段”+ 提示用户用 Developer: Inspect Editor Tokens and Scopes 验证。
3) 写入用户 settings 有风险。
   - 方案：写入前快照 + 一键恢复；只覆盖扩展管理的键空间。

## 5. 技术方案概览（How）
### 5.1 核心模块
- Profile 管理：标准层 + 语言层 + 主题绑定。
- TokenType 发现：扫描扩展贡献（并提供“缺扩展提示安装”）。
- Settings 应用器：
  - 静态模式：按主题写入 editor.semanticTokenColorCustomizations 的 theme block。
  - 动态模式（后续）：监听 active editor 的 languageId，切换写入规则。
- 预览系统：
  - 注册 TextDocumentContentProvider（如 	okenstyler-preview:）生成虚拟文档。
  - 预览文档展示 C#/通用代码片段；改配置后 debounce 写入 settings，预览实时变化。

### 5.2 数据结构（建议）
- TokenStyle = { foreground?, bold?, italic?, underline? }
- Profile = { id, name, enabled, boundThemes[], standardRules{}, languageRules{[lang]: rules{} } }

### 5.3 本地化策略
- 扩展侧：package.nls.json + package.nls.zh-cn.json。
- Webview：由 extension 根据 scode.env.language 下发字符串表。
- token label：
  - 英文 UI：直接显示 tokenType（例如 constant）。
  - 中文 UI：显示“语言前缀 + 简短语义”（例如 C#.常量标识符）。

## 6. 工作分解与里程碑（Plan）

### 里程碑 M0：立项与脚手架（1 天）
- 输出：
  - 扩展工程初始化（TypeScript）
  - 基础命令 Open Token Styler
  - Webview 空壳 + 预览文档 provider 空壳
- 验证：命令能打开面板；预览文档能打开。

### 里程碑 M1：配置域与落地写入（1-2 天）
- 任务：
  1) 定义 Profile JSON schema（存储在 globalState/workspaceState 或配置文件）。
  2) 实现“生成 settings payload”（theme-scoped block）。
  3) 写入策略：只写扩展管理范围；写入前保存快照；实现 Restore。
- 验证：
  - 变更能写入 settings；恢复能回滚到写入前。

### 里程碑 M2：TokenType 发现与 C# 适配（1-2 天）
- 任务：
  1) 扫描已安装扩展贡献的 semanticTokenTypes（优先 C#）。
  2) 若未安装推荐扩展：UI 提示并一键跳转/安装。
  3) 生成“标准 + C# token types”列表（分组展示）。
- 验证：C# token types 列表能在 UI 展示，且与扩展贡献一致。

### 里程碑 M3：实时预览（1-2 天）
- 任务：
  1) 内置预览片段（基础覆盖：keyword/comment/operator/type/method/property/field/enum/string/number 等）。
  2) UI 改值 → debounce → 写入 settings → 预览编辑器实时变化。
- 验证：在预览窗口中，修改颜色/粗体能立即看到差异。

### 里程碑 M4：完整 UI 与本地化（1-2 天）
- 任务：
  1) Token 列表搜索、分组、选中编辑。
  2) 中英文显示切换：英文显示 tokenType；中文显示语义标签。
  3) Profile 管理：新增/复制/删除/启用/绑定主题。
- 验证：中文界面能显示 C#.常量标识符 等标签；英文界面显示原 tokenType。

### 里程碑 M5：增强（可选，需二次审批）
- 动态模式：按 active editor languageId 自动切换应用。
- 更多语言适配（C/C++、TS/JS…）。

## 7. 验收标准（Acceptance Criteria）
- 能在 UI 中对任意 tokenType 设置 oreground + old/italic/underline。
- 能按主题保存多套配置，并在切换主题时生效。
- 能通过预览窗口实时看到效果。
- 不破坏用户其它 settings：
  - 仅改动扩展管理范围
  - 支持一键恢复到写入前
- 中英文显示符合要求：
  - 英文 UI：tokenType 原名
  - 中文 UI：语义标签（例如 C#.常量标识符）

## 8. 决策点（需要你审批/确认）
1) MVP 是否只做“静态模式（按主题）”，暂不做动态模式？（推荐：是）
2) 首个语言适配是否仅 C#？（推荐：是）
3) 写入默认目标：用户级（Global）还是工作区级（Workspace）？（建议默认 Global，提供切换）

## 9. 下一步（等待审批）
- 你确认以上计划无误后，我再开始创建扩展工程与实现 M0/M1。
